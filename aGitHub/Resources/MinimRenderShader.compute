// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel Prepare
#pragma kernel PaintLocal
#pragma kernel PaintGlobal
#pragma kernel PaintColorierGlobal
#pragma kernel BlitzMondeALum
#pragma kernel Lumiere_1
#pragma kernel Clear
#pragma kernel Lumiere_3
#pragma kernel BlitzLum_1
#pragma kernel AddBox
#pragma kernel Sauver
#pragma kernel Load
#pragma kernel Sauver_Piece
#pragma kernel Load_Piece
#pragma kernel MinMain
#pragma kernel MoyenMain

struct LOD
    {
    int i;
    };

struct ColorSave
    {
    float4 _color;
    };

struct ColorSavePiece
    {
    float4 _color;
    int    _pos;
    };

struct GeneralInfo
    {
    float4 posCoursor;
    };

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> mondePosTex;
Texture3D<float4>   Input;
Texture2D<float4>   RayMap, RayMap_2;
Texture2D<float4>   tex_1, tex_2, tex_3;
RWTexture3D<float4> mondeTex;
RWTexture3D<float4> tempMonde;
RWTexture3D<float4> vueMonde;
RWTexture3D<float4> ombre3DCard;
RWTexture3D<float4> LOD_1;
RWStructuredBuffer<LOD>            buffLOD;
RWStructuredBuffer<float4>         buffSave;
RWStructuredBuffer<ColorSavePiece> buffSaveLoadPiece;
RWStructuredBuffer<GeneralInfo>    genInfo;

float3 camPos, viewDIr, targ_0, targ_1, targ_2, targ_3, targ_4, vectorDirPaint;
float3 posTarget;
float4 colorPaint;
float4 bias_1;
float4 ombreColor;
float3 sizeChuck;
int    sizeBuffer;
float rad_1, durete, k_1, k_2, k_3, k_4, k_5, layerA, layerB, lumIntens;

bool estAdd;

float4 StepMarch3(float3 startPoint, float3 dir_1, float3 dir_2, out float zVal, out float3 worldPos);
float4 StepSimple(float3 startPoint, float3 dir_1, float3 dir_2);
float4 StepMoyen(float3 startPoint, float3 dir_1, float3 dir_2);
float4 LumMarch(float3 startPoint, float3 dir_1, float3 dir_2, float k);
float3 TransformRayDir(float3 pos);
float3 DetectVoxelOnRay(float3 startPoint, float3 dir);
bool   estCorrectIndex(float3 _val, float3 _max);
int    Transform3Dto1D(int3 id, int3 dim);
int3   Transform1Dto3D(int pos, int3 dim);
float3 GetNormal      (int3 worldPos);


[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
    {   
    //return;
    // TODO: insert actual code here!
    float3 rayDir   = tex_1[id.xy].rgb;
    float3 rayDir_2 = TransformRayDir(RayMap[id.xy].rgb);
    float3 startPos = camPos;
    
    float z = 0.0f;
    float3 worldPos = float3(1, 0, 0);
    
    float4 res = StepMarch3(startPos, rayDir, rayDir_2, z, worldPos);
    float3 pos = DetectVoxelOnRay(startPos, rayDir_2) / 256.0f;
    mondePosTex[int2(id.x, 1024 - id.y)] = float4(pos, 1);
    //Result[int2(id.x, 1024 - id.y)] = float4(pos, 1);
    
    if (id.x == 0 && id.y == 0 && id.z == 0)
        {
        float3 mousePos = mondePosTex[targ_0.xy].rgb;
        GeneralInfo gi;
        gi.posCoursor = float4(mousePos, 0.67f);
        genInfo[0] = gi;
        }
    
    Result[ int2(id.x, 1024 - id.y) ] = res;
    return;
    //Result[id.xy] = float4(0, 0, 0, 1);
    
    if( distance(targ_0.xy, id.xy) < 10.0f)
        {   
        Result[id.xy] = Result[id.xy] + float4(1, 0, 0, 1);
        }
    }


[numthreads(32, 32, 1)]
void MinMain(uint3 id : SV_DispatchThreadID)
{
    //return;
    // TODO: insert actual code here!
    float3 rayDir = tex_1[id.xy].rgb;
    float3 rayDir_2 = TransformRayDir(RayMap[id.xy].rgb);
    float3 startPos = camPos;
    
    float z = 0.0f;
    float3 worldPos = float3(1, 0, 0);
    
    float4 res =  StepSimple(startPos, rayDir, rayDir_2);
    float3 pos = DetectVoxelOnRay(startPos, rayDir_2) / 256.0f;
    mondePosTex[int2(id.x, 1024 - id.y)] = float4(pos, 1);
    
    if (id.x == 0 && id.y == 0 && id.z == 0)
        {
        float3 mousePos = mondePosTex[targ_0.xy].rgb;
        GeneralInfo gi;
        gi.posCoursor = float4(mousePos, 0.67f);
        genInfo[0] = gi;
        }
    
    Result[int2(id.x, 1024 - id.y)] = res;
    return;
    }

[numthreads(32, 32, 1)]
void MoyenMain(uint3 id : SV_DispatchThreadID)
    {
    //return;
    // TODO: insert actual code here!
    float3 rayDir = tex_1[id.xy].rgb;
    float3 rayDir_2 = TransformRayDir(RayMap[id.xy].rgb);
    float3 startPos = camPos;
    
    float z = 0.0f;
    float3 worldPos = float3(1, 0, 0);
    
    float4 res = StepMoyen(startPos, rayDir, rayDir_2);
    float3 pos = DetectVoxelOnRay(startPos, rayDir_2) / 256.0f;
    mondePosTex[int2(id.x, 1024 - id.y)] = float4(pos, 1);
    
    if (id.x == 0 && id.y == 0 && id.z == 0)
        {
        float3 mousePos = mondePosTex[targ_0.xy].rgb;
        GeneralInfo gi;
        gi.posCoursor = float4(mousePos, 0.67f);
        genInfo[0] = gi;
        }
    
    Result[int2(id.x, 1024 - id.y)] = res;
    return;
    }

[numthreads(8, 8, 8)]
void Prepare(uint3 id : SV_DispatchThreadID)
    {    
    mondeTex[id.xyz] = Input.Load(int4(id.xyz, 0));
    }

[numthreads(32, 32, 1)]
void PaintLocal(uint3 id : SV_DispatchThreadID)
    {    
    float bias = 0.0f;;
    if(estAdd)
        {
        bias = 1.0f;
        }
    
    if (distance(targ_0.rg, id.xy) < rad_1)
        {               
        float3 pos = mondePosTex[id.xy].rbg * 256.0f;
        float3 rayDir = TransformRayDir(RayMap[id.xy].rgb).rbg * bias;
        mondeTex[pos + rayDir] = lerp(mondeTex[pos + rayDir], colorPaint, durete);
        }

    }

[numthreads(8, 8, 8)]
void PaintGlobal(uint3 id : SV_DispatchThreadID)
    {
    float3 tarp = vectorDirPaint;
    int3   pos_1 = mondePosTex[targ_0.xy].rbg * 256;
    int3   pos_2 = pos_1 - tarp * 10;
    
    float3 collidePos;
    float dist = 0.0f;    distance(id.xy, pos_2.xy);
    float revDist = rad_1 - dist;
    
    bool predicatus = false;
    
    if (abs(tarp.x) > 0.1f)
        {
        predicatus = (id.x == pos_2.x);
        dist = distance(id.yz, pos_2.yz);
        }
    
    if (abs(tarp.y) > 0.1f)
        {
        predicatus = (id.y == pos_2.y);
        dist = distance(id.xz, pos_2.xz);
        }
    
    if (abs(tarp.z) > 0.1f)
        {
        dist = distance(id.xy, pos_2.xy);
        predicatus = (id.z == pos_2.z);
        }
    
    if ( dist < rad_1 && predicatus)
        {
        for (int i = 0; i < 25; i++)
            {
            collidePos = id.xyz + tarp * i;
        
            if (mondeTex[collidePos].a > 0.01f)
                {               
                mondeTex[collidePos - tarp] = colorPaint;
                    
                    
                return;
                }
            }       
        
        //mondeTex[id.xyz] = colorPaint;
        }         

    }


///раскрашивание глобальное
[numthreads(8, 8, 8)]
void PaintColorierGlobal(uint3 id : SV_DispatchThreadID)
    {
    float3 pos = mondePosTex[targ_0.xy].rbg * 256.0f;  //положение курсора в трехмерном пространстве
    
    if (distance(pos, id.xyz) < rad_1 && mondeTex[id.xyz].a > 0.05f)
        {              
        mondeTex[id.xyz] = lerp(mondeTex[id.xyz], colorPaint, durete);
        }
    }



[numthreads(8, 8, 8)]
void BlitzMondeALum(uint3 id : SV_DispatchThreadID)
    {
    
    }

[numthreads(8, 8, 16)]
void Lumiere_1(uint3 id : SV_DispatchThreadID)
    {   
    float3 rayDir = tex_1[id.xy].rgb;
    float3 rayDir_2 = TransformRayDir(RayMap[id.xy * 4].rgb);
    float3 startPos = camPos;
    
    float z = 0.0f;
    float3 worldPos = float3(1, 0, 0);
    
    float4 res = LumMarch(startPos, rayDir, rayDir_2, id.z);
    }

[numthreads(8, 8, 8)]
void Clear(uint3 id : SV_DispatchThreadID)
    {
    tempMonde[id.xyz] = mondeTex[id.xyz];
    }


[numthreads(8, 8, 8)]
void Lumiere_3(uint3 id : SV_DispatchThreadID)
    {
    int pos = Transform3Dto1D(id.xyz / 8, int3(32, 32, 32));
    
    if(mondeTex[id.xyz].a > 0.01f)
        {
        InterlockedAdd(buffLOD[pos].i, 1);
        }   
    
    }

[numthreads(8, 8, 8)]
void BlitzLum_1(uint3 id : SV_DispatchThreadID)
    {   
    int pos = Transform3Dto1D(id.xyz / 8, int3(32, 32, 32));
    
    if (buffLOD[pos].i > 0)
        {
        LOD_1[id.xyz] = float4(0, 0, 0, 0);
        }
    
    else
        {
        LOD_1[id.xyz] = float4(1, 1, 1, 1);
        }

    }

[numthreads(8, 8, 8)]
void AddBox(uint3 id : SV_DispatchThreadID)
    {
    bool estX = id.x > targ_1.x && id.x < targ_2.x;
    bool estY = id.y > targ_1.y && id.y < targ_2.y;
    bool estZ = id.z > targ_1.z && id.z < targ_2.z;
    
    if (estX && estY && estZ && mondeTex[id.xyz].a < 0.2f)
        {    
        mondeTex[id.xzy] = colorPaint;
        }
    }


[numthreads(8, 8, 8)]
void Sauver(uint3 id : SV_DispatchThreadID)
    {
    int pos = Transform3Dto1D(id.xyz, int3(255, 255, 255));
    buffSave[pos] = mondeTex[id.xyz];
    //mondeTex[id.xyz] = float4(1, 0, 0, 0.01f);
    }

[numthreads(8, 8, 8)]
void Load(uint3 id : SV_DispatchThreadID)
    {
    int pos = Transform3Dto1D(id.xyz, int3(255, 255, 255));
    mondeTex[id.xyz] = buffSave[pos];
    }

[numthreads(32, 32, 1)]
void Sauver_Piece(uint3 id : SV_DispatchThreadID)
    { 
    int count = id.x * 32 + id.y; //id.x; //Transform3Dto1D(id, int3(targ_3)); 
    int3 pos3d = Transform1Dto3D(count, int3(targ_4));
    //mondeTex[pos3d.xzy + targ_3.xzy] = float4(1, 1, 0, 1);    
    ColorSavePiece col;
    col._color = tempMonde[pos3d.xzy + targ_3.xzy];
    col._pos = Transform3Dto1D(pos3d.xzy + targ_3.xzy, int3(255, 255, 255) );
    buffSaveLoadPiece[count] = col; 
    
    //mondeTex[Transform1Dto3D(col._pos, int3(255, 255, 255))] = float4(1, 1, 0, 1);
    
    return;
    
    int pos = Transform3Dto1D(id.xzy, int3(targ_3.xzy)); //  -int3(-2, -2, -2) + int3(k_1, k_2, k_3));
    int pos_2 = Transform3Dto1D(id.xzy + int3(targ_3.xzy), int3(255, 255, 255));
    ColorSavePiece sav;
   
    sav._color = tempMonde[id.xzy + targ_3.xzy];
    sav._pos = pos_2;
    
    if(pos < sizeBuffer)
        {   
        buffSaveLoadPiece[pos] = sav;
        }
    
    }

/*

[numthreads(16, 1, 1)]
void Sauver_Piece(uint3 id : SV_DispatchThreadID)
    { 
    int count =  id.x; //Transform3Dto1D(id, int3(targ_3)); //
    int3 pos3d = Transform1Dto3D(count, int3(targ_4));
    //mondeTex[pos3d.xzy + targ_3.xzy] = float4(1, 1, 0, 1);    
    ColorSavePiece col;
    col._color = tempMonde[pos3d.xzy + targ_3.xzy];
    col._pos = Transform3Dto1D(pos3d.xzy + targ_3.xzy, int3(255, 255, 255) );
    buffSaveLoadPiece[count] = col; 
    
    //mondeTex[Transform1Dto3D(col._pos, int3(255, 255, 255))] = float4(1, 1, 0, 1);
    
    return;
    
    int pos = Transform3Dto1D(id.xzy, int3(targ_3.xzy)); //  -int3(-2, -2, -2) + int3(k_1, k_2, k_3));
    int pos_2 = Transform3Dto1D(id.xzy + int3(targ_3.xzy), int3(255, 255, 255));
    ColorSavePiece sav;
   
    sav._color = tempMonde[id.xzy + targ_3.xzy];
    sav._pos = pos_2;
    
    if(pos < sizeBuffer)
        {   
        buffSaveLoadPiece[pos] = sav;
        }
    
    }
*/

[numthreads(32, 32, 1)]
void Load_Piece(uint3 id : SV_DispatchThreadID)
    {
    int count = id.x * 32 + id.y;
    ColorSavePiece col = buffSaveLoadPiece[count];
    int3 worldPos = Transform1Dto3D(col._pos, int3(255, 255, 255));
    mondeTex[worldPos] = col._color;
    return;    
    
    int pos = Transform3Dto1D(id.xzy, targ_3.xzy);
    
    if(pos < sizeBuffer )
        {    
        int pos_3 = buffSaveLoadPiece[pos]._pos;      
        int3 pos_3d_W = Transform1Dto3D(pos_3, int3(255, 255, 255));
        mondeTex[pos_3d_W] = buffSaveLoadPiece[pos]._color;
        }
    }

float4 StepMarch3(float3 startPoint, float3 dir_1, float3 dir_2, out float zVal, out float3 worldPos)
    {    
    int maxStep = 400;
    const float maxDistanse = 512.0f;
    
    float stepVal = 1.0f;
    
    zVal = 1.0f;
    
    worldPos = float3(0, 0, 0);   
    const float3 dirStep = normalize(dir_2);
    
    float transparensia = 1.0f;
    float3 colorTrans = float3(0.25f, 0.25f, 1);
    zVal = -1;
    
    bool isDetect = false;
    
    float3 lumColor = float3(1, 1, 1);
    float3 posLumSouslo = float3(255, 255, 255);
    float4 courrColor = float4(0, 0, 1, 1);
    //float3 courrPosLum = 
    
    for (float i = maxStep; i > 0 ; i--)
        {        
        float3 courrPos = startPoint + dirStep * i;
        
        //i = i - 8 * LOD_1[courrPos.xzy].r;// * LOD_1[courrPos.xzy + dirStep * 6].r;
        
        //float3 norm = clamp(GetNormal(courrPos.xzy), float3(-1, -1, -1), float3(1, 1, 1));
        
        courrColor = mondeTex[courrPos.xzy] * ombre3DCard[courrPos.xzy];
        //courrColor = float4(norm.rgb, mondeTex[courrPos.xzy].w);
        
        
        if ( !estCorrectIndex(courrPos.xzy, int3(255, 255, 255)) )
            {
            courrColor = float4(0, 0, 0, 0);
            }          
        
        colorTrans = lerp(colorTrans.rgb, courrColor.rgb, courrColor.a);
        }   
    
    return float4(colorTrans.rgb, 1);
    }

float4 StepSimple(float3 startPoint, float3 dir_1, float3 dir_2)
    {
    int maxStep = 350;
    const float maxDistanse = 512.0f;      
    const float3 dirStep = normalize(dir_2);
    
    float transparensia = 1.0f;
    float3 colorTrans = float3(0.25f, 0.25f, 1);
    
    bool isDetect = false;
    
    float3 lumColor = float3(1, 1, 1);
    float3 posLumSouslo = float3(255, 255, 255);
    float4 courrColor = float4(0, 0, 1, 1);
    //float3 courrPosLum = 
    
    for (float i = 0; i < maxStep; i++)
        {
        float3 courrPos = startPoint + dirStep * i;       
        courrColor = mondeTex[courrPos.xzy];       
        
        if (!estCorrectIndex(courrPos.xzy, int3(255, 255, 255)))
            {
            courrColor = float4(0, 0, 0, 0);
            }
        
        if(courrColor.a > 0.01f)
            {
            return float4(courrColor.rgb * (1 - i/maxStep), 1);
            }
        }
    
    return float4(colorTrans.rgb, 1);
    }   

float4 StepMoyen(float3 startPoint, float3 dir_1, float3 dir_2)
    {
    int maxStep = 350;
    const float maxDistanse = 512.0f;
    const float3 dirStep = normalize(dir_2);
    
    float transparensia = 1.0f;
    float3 colorTrans = float3(0.25f, 0.25f, 1);
    
    bool isDetect = false;
    
    float3 lumColor = float3(1, 1, 1);
    float3 posLumSouslo = float3(255, 255, 255);
    float4 courrColor = float4(0, 0, 1, 1);
    //float3 courrPosLum = 
    
    for (float i = maxStep; i > 1; i--)
        {
        float3 courrPos = startPoint + dirStep * i;
        courrColor = mondeTex[courrPos.xzy];
        
        if (!estCorrectIndex(courrPos.xzy, int3(255, 255, 255)))
            {
            courrColor = float4(0, 0, 0, 0);
            }
        
        colorTrans = lerp(colorTrans.rgb, courrColor.rgb * (1.0f - i / maxStep), courrColor.a);
    }
    
    return float4(colorTrans.rgb, 1);
    }

float4 LumMarch(float3 startPoint, float3 dir_1, float3 dir_2, float k)
    {
    int maxStep = 400;
    const float maxDistanse = 512.0f;    
    
    const float3 dirStep = normalize(dir_2);
    
    bool isDetect = false;
    
    float4 lumColor = float4(1, 1, 1, 1);
    float3 posLumSouslo = float3(255, 255, 255);
    //float3 courrPosLum =        

    float3 courrPos = startPoint + dirStep * k;                             
    float4 courrColor;
    float intens = lumIntens * 3.0f;
    float3 tone = lumColor.rgb;
    float3 dirLum = normalize(bias_1.xzy - courrPos.xzy);
    
    float3 norm = clamp(GetNormal(courrPos.xzy), float3(-1, -1, -1), float3(1, 1, 1));
    float koeffNorm = dot(norm, dirLum);
    float dist = distance(courrPos, bias_1.xyz);
    float distKoeff = clamp(koeffNorm, 0, 1) * clamp(1500 * pow(dist, -1.5), 0, 1);   
    
    for (float count = 3; count < dist; count += 1.0f)
        {
        float3 courrPos_3 = courrPos.xzy + dirLum * count;      

        count = count + 8 * LOD_1[courrPos_3].r;
             
        
        courrColor = mondeTex[courrPos_3];
        intens *= 1 - courrColor.a;
        tone = lerp(tone, tone * courrColor.rgb, courrColor.a);
        lumColor = float4(tone.rgb * intens, 1);            
        
        if(intens < 0.01f)
            {
            ombre3DCard[courrPos.xzy] = lumColor * float4(distKoeff, distKoeff, distKoeff, 1);
            return lumColor;
            }
        
        }       
        
    ombre3DCard[courrPos.xzy] = lumColor * float4(distKoeff, distKoeff, distKoeff, 1);
        
    
    //zVal = -1.0f;
    //worldPos = float3(0, 0, 0);
    //return fond3;
    
    return float4(lumColor.rgb, 1);
    }

float3 DetectVoxelOnRay(float3 startPoint, float3 dir)
    {
    int maxSpet = 1000;
    const float maxDistanse = 512.0f;
    
    float step = 1.0f;
    
    const float3 dirStep = normalize(dir) * 0.8f;
    bool isDetect = false;
    
    float3 res = float3(-3, -3, -3);  
    
    for (float i = 0; i < maxSpet; i++)
        {
        //step *= 1.01f;
        
        float3 courrPos = startPoint + dirStep * i;
        
        
        //intPos = int3(intPos.x % size, intPos.y % size, intPos.z % 32);
        float minLim = 0.0f;
        //return float4(courrPos, 1.0);
        float h3 = 256.0f;                   
        float4 courrColor = mondeTex[courrPos.xzy];
        
        if (courrPos.x < 0 || courrPos.y < 0 || courrPos.z < 0)
            {
            courrColor = float4(0, 0, 0, 0);
            }
        
        if (courrColor.a > 0.03f)
            {                    
            res = courrPos;
            return res;
            }
            
        }
    
    return res;    
    }

float3 TransformRayDir(float3 pos)
    {
    float3 res = (pos - float3(0.5f, 0.5f, 0.5f)) * 2.0f;
    return res;
    }

bool estCorrectIndex(float3 _val, float3 _max)
    {
    if ( _val.x >= 0 && _val.y >= 0 && _val.z >= 0 && _val.x <= _max.x && _val.y <= _max.y && _val.z <= _max.z )
        {
        return true;
        }
    else
        {
        return false;
        }
    }

int Transform3Dto1D(int3 id, int3 dim)
    {
    if (id.x < 0 || id.x > dim.x)
        {
        return -1;
        }
    
    if (id.y < 0 || id.y > dim.y)
        {
        return -1;
        }
    
    if (id.z < 0 || id.z > dim.z)
        {
        return -1;
        }
    
    int i = id.z * dim.x * dim.y + id.y * dim.y + id.x;
    return i;
    }

int3 Transform1Dto3D(int pos, int3 dim)
    {
    int idx = pos;
    
    int z = floor(idx / (dim.x * dim.y));
    idx -= (z * dim.x * dim.y);
    int y = floor(idx / dim.x);
    int x = idx % dim.x;
    return int3(x, y, z);
    }

float3 GetNormal(int3 worldPos)
    {
    int3 LeftIntPos = worldPos;
            
    float3 norm = float3(0, 0, 0);
    float porog = 0.1f;
            
    if (mondeTex[LeftIntPos + int3(1, 0, 0)].a < porog)
        {
        norm += float3(1, 0, 0);
        }
            
    if (mondeTex[LeftIntPos - int3(1, 0, 0)].a < porog)
        {
        norm += float3(-1, 0, 0);
        }
            
    if (mondeTex[LeftIntPos + int3(0, 1, 0)].a < porog)
        {
        norm += float3(0, 1, 0);
        }
            
    if (mondeTex[LeftIntPos - int3(0, 1, 0)].a < porog)
        {
        norm += float3(0, -1, 0);
        }
            
    if (mondeTex[LeftIntPos + int3(0, 0, 1)].a < porog)
        {
        norm += float3(0, 0, 1);
        }
            
    if (mondeTex[LeftIntPos - int3(0, 0, 1)].a < porog)
        {
        norm += float3(0, 0, -1);
        }
            
    norm = normalize(norm);
    //norm = norm * 0.5f + (0.5f, 0.5f, 0.5f);
    return norm;
}

/*

// TODO: insert actual code here!
    const int size = 200;
    const int senter = 0;
    
    const float3 vecPrig = float3(0, 0, 1);
    float angleX = (size - id.x) * k_2 / 100;
    float angleY = (size - id.y) * k_2 / 100;
    float sinX = sin(angleX);
    float cosX = cos(angleX);
    float sinY = sin(angleY);
    float cosY = cos(angleY);
    
    
    float3x3 matxX = float3x3(
                             float3(1.0f, 0.0f, 0.0f),
                             float3(0.0f, cosX, -sinX),
                             float3(0.0f, sinX, cosX)
                             );
    
    float3x3 matxY = float3x3(
                             float3(cosY, 0.0f, sinY),
                             float3(0.0f, 1.0f, 0.0f),
                             float3(-sinY, 0.0f, cosY)
                             );
    
    float3 resVec = mul(vecPrig, matxX);
    resVec = normalize( mul(resVec, matxY) );

    float4 lumColor;
    float4 courrColor_2;
    float intens = 1.0f;
    float3 tone = float3(1, 1, 1);
    
    for (float count = 3; count < 250; count += 5.0f)
        {
        float3 courrPos_3 = clamp(lerp(courrPos_2.xzy, bias_1.xzy, count / 250), float3(0, 0, 0), float3(255, 255, 255));
        courrColor_2 = mondeTex[courrPos_3];
        intens *= 1 - courrColor_2.a;
        lumColor = float4(tone.rgb * intens, 1);
        }
        
    courrColor = mondeTex[courrPos_2.xzy] * lumColor;


*/